/*
 * generated by Xtext
 */
package org.xtext.example.mydsl1.validation

import featureModel.BinaryOperation
import featureModel.BinaryOperator
import featureModel.Expression
import featureModel.Feature
import featureModel.Identifier
import featureModel.NULL
import featureModel.SimpleType
import featureModel.UnaryOperation
import featureModel.UnaryOperator
import org.eclipse.xtext.validation.Check
import featureModel.Model

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class MyDslValidator extends AbstractMyDslValidator {

	var count = 0;
	@Check
	def onlyOneSelectGroupPerFeature(Feature it){
		count = 0;
		groups.forEach[g | if (!g.inclusive) count++ ]
		if(count > 1){
			error('Only 1 exclusive select in a feature!', it, null, '')
		}
	}

	@Check
	def onlyRootFeatureCanHaveConstraints(Model it){
		val r = rootFeature.forall[features |  check(features)]
		if(!r){
			error('Put constraints after the last feature.', it, null, 'put constraints in root feature')
		}
	}
	
	def boolean check(Feature it){
		features.forall[features | checkNotContainConstraints(features)]
	}
	
	def boolean checkNotContainConstraints(Feature it) {
		val r = constraints.isEmpty
		if(!r){
			error('only rootfeature can have constraints', it, null, 'put constraints in root feature')
		}
		return r && features.forall[features | checkNotContainConstraints(features)]
	}

	@Check
	def topConstraintShouldBeBoolean(Feature f) {
//		f.constraints.forall[topConstraint | getType(topConstraint) == SimpleType.get('boolean')]
		for (Expression constraint : f.constraints) {
			if (!(getType(constraint) == SimpleType.get('boolean'))){
					error('top constraint must be boolean', f, null, 'invalid type')
			}
		}
	}

	def SimpleType getType(Expression e) {
	//Identifier
		if (e instanceof Identifier) {
			val id = e as Identifier
			id.ref.get(id.ref.size - 1).type
	//BinaryOperation
		}else if (e instanceof BinaryOperation) {
			val binOp = e as BinaryOperation
			val left = binOp.lexp
			val right = binOp.rexp
			val op = binOp.operator
			val ltype = getType(left)
			val rtype = getType(right)
			if (ltype == rtype || ltype == SimpleType.get('nulltype') || rtype == SimpleType.get('nulltype')) {
				if (op == BinaryOperator.get('And') || op == BinaryOperator.get('Or')) {
					if (ltype == SimpleType.get('boolean')) {
						ltype
					} else {
						throw new Exception("invalid type, must be boolean with And or Or operator")
					}
				} else if (op == BinaryOperator.get('Equals') || op == BinaryOperator.get('Higher') || op == BinaryOperator.get('Lower')) {
					SimpleType.get('boolean')
				} else if (	op == BinaryOperator.get('Divide') || op == BinaryOperator.get('Multiply') ||
							op == BinaryOperator.get('Add') || op == BinaryOperator.get('Subtract')) {
					if (ltype == rtype && 
						(ltype == SimpleType.get('int') || ltype == SimpleType.get('double'))
					) {
						ltype
					} else {
						throw new Exception("invalid type")
					}
				}
			}
	//UnaryOperation
		}else if (e instanceof UnaryOperation) {
			val ex = e as UnaryOperation
			val extype = getType(ex.exp)
			if( (ex.operator == UnaryOperator.get('Not') && (extype == SimpleType.get('boolean') || extype == SimpleType.get('nulltype') ))
					|| 
				(ex.operator == UnaryOperator.get('Minus') && (extype == SimpleType.get('int') || extype == SimpleType.get('double'))) ){
				extype
			}else{
				throw new Exception("invalid type")
			}
	//Number
		}else if (e instanceof Number) {
			SimpleType.get('int')
	//NULL
		}else if(e instanceof NULL){
			SimpleType.get('nulltype')
		}else{
			SimpleType.get('nulltype')
		}
		//TODO add True and False as expressions
	}

}
