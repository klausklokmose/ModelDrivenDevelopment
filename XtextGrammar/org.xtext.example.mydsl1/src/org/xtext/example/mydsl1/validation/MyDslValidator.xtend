/*
 * generated by Xtext
 */
package org.xtext.example.mydsl1.validation

import featureModel.BinaryOperation
import featureModel.BinaryOperator
import featureModel.Expression
import featureModel.Feature
import featureModel.Identifier
import featureModel.NULL
import featureModel.SimpleType
import featureModel.UnaryOperation
import featureModel.UnaryOperator
import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class MyDslValidator extends AbstractMyDslValidator {

	@Check
	def TopConstraintShouldBeBoolean(Feature f) {
//		f.constraints.forall[topConstraint | getType(topConstraint) == SimpleType.get('boolean')]
		
		for (Expression constraint : f.constraints) {
			if (!(getType(constraint) == SimpleType.get('boolean'))){
					warning('top constraint should be boolean', f, null, 'invalid type')
			}
		}
	}

	def SimpleType getType(Expression e) {
//Identifier
		if (e instanceof Identifier) {
			val id = e as Identifier
			id.ref.get(id.ref.size - 1).type
//BinaryOperation
		} else if (e instanceof BinaryOperation) {
			val binOp = e as BinaryOperation
			val left = binOp.lexp
			val right = binOp.rexp
			val op = binOp.operator
			val ltype = getType(left)
			val rtype = getType(right)
			if (ltype == rtype || ltype == SimpleType.get('nulltype') || rtype == SimpleType.get('nulltype')) {
				if (op == BinaryOperator.get('And') || op == BinaryOperator.get('Or')) {
					if (ltype == SimpleType.get('boolean')) {
						ltype
					} else {
						throw new Exception("invalid type, must be boolean with And or Or operator")
					}
				} else if (op == BinaryOperator.get('Equals') || op == BinaryOperator.get('Higher') || op == BinaryOperator.get('Lower')) {
					SimpleType.get('boolean')
				} else if (	op == BinaryOperator.get('Divide') || op == BinaryOperator.get('Multiply') ||
							op == BinaryOperator.get('Add') || op == BinaryOperator.get('Subtract')) {
								
					if (ltype == rtype && 
						(ltype == SimpleType.get('int') || ltype == SimpleType.get('double'))
					) {
						ltype
					} else {
						throw new Exception("invalid type")
					}
				}
			}
//UnaryOperation
		} else if (e instanceof UnaryOperation) {
			val ex = e as UnaryOperation
			val extype = getType(ex.exp)
			if( (ex.operator == UnaryOperator.get('Not') && (extype == SimpleType.get('boolean') || extype == SimpleType.get('nulltype') ))
					|| 
				(ex.operator == UnaryOperator.get('Minus') && (extype == SimpleType.get('int') || extype == SimpleType.get('double'))) ){
				extype
			}else{
				throw new Exception("invalid type")
			}
//Number
		} else if (e instanceof Number) {
			SimpleType.get('int')
//NULL
		} else if(e instanceof NULL){
			SimpleType.get('nulltype')
		} else{
			SimpleType.get('nulltype')
		}
		//TODO add True and False as expressions
	}

}
