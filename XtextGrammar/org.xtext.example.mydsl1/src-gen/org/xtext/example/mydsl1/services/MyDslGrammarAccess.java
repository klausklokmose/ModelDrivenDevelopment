/*
* generated by Xtext
*/
package org.xtext.example.mydsl1.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class MyDslGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cModelAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cModelKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cRootKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cRootFeatureAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cRootFeatureFeatureParserRuleCall_3_1_0 = (RuleCall)cRootFeatureAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cRootKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cRootFeatureAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cRootFeatureFeatureParserRuleCall_3_2_1_0 = (RuleCall)cRootFeatureAssignment_3_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Model:
		//	{Model} "Model" "{" ("Root" RootFeature+=Feature ("Root" RootFeature+=Feature)*)? "}";
		public ParserRule getRule() { return rule; }

		//{Model} "Model" "{" ("Root" RootFeature+=Feature ("Root" RootFeature+=Feature)*)? "}"
		public Group getGroup() { return cGroup; }

		//{Model}
		public Action getModelAction_0() { return cModelAction_0; }

		//"Model"
		public Keyword getModelKeyword_1() { return cModelKeyword_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//("Root" RootFeature+=Feature ("Root" RootFeature+=Feature)*)?
		public Group getGroup_3() { return cGroup_3; }

		//"Root"
		public Keyword getRootKeyword_3_0() { return cRootKeyword_3_0; }

		//RootFeature+=Feature
		public Assignment getRootFeatureAssignment_3_1() { return cRootFeatureAssignment_3_1; }

		//Feature
		public RuleCall getRootFeatureFeatureParserRuleCall_3_1_0() { return cRootFeatureFeatureParserRuleCall_3_1_0; }

		//("Root" RootFeature+=Feature)*
		public Group getGroup_3_2() { return cGroup_3_2; }

		//"Root"
		public Keyword getRootKeyword_3_2_0() { return cRootKeyword_3_2_0; }

		//RootFeature+=Feature
		public Assignment getRootFeatureAssignment_3_2_1() { return cRootFeatureAssignment_3_2_1; }

		//Feature
		public RuleCall getRootFeatureFeatureParserRuleCall_3_2_1_0() { return cRootFeatureFeatureParserRuleCall_3_2_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class FeatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Feature");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSolitaryFeatureParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cGroupedFeatureParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Feature:
		//	SolitaryFeature | GroupedFeature;
		public ParserRule getRule() { return rule; }

		//SolitaryFeature | GroupedFeature
		public Alternatives getAlternatives() { return cAlternatives; }

		//SolitaryFeature
		public RuleCall getSolitaryFeatureParserRuleCall_0() { return cSolitaryFeatureParserRuleCall_0; }

		//GroupedFeature
		public RuleCall getGroupedFeatureParserRuleCall_1() { return cGroupedFeatureParserRuleCall_1; }
	}

	public class SolitaryFeatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SolitaryFeature");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFeatureKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRequiredAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRequiredSolitaryTypeEnumRuleCall_1_0 = (RuleCall)cRequiredAssignment_1.eContents().get(0);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeSimpleTypeEnumRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameEStringParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cLeftCurlyBracketKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cGroup_4.eContents().get(1);
		private final Assignment cFeaturesAssignment_4_1_0 = (Assignment)cGroup_4_1.eContents().get(0);
		private final RuleCall cFeaturesSolitaryFeatureParserRuleCall_4_1_0_0 = (RuleCall)cFeaturesAssignment_4_1_0.eContents().get(0);
		private final Assignment cFeaturesAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cFeaturesSolitaryFeatureParserRuleCall_4_1_1_0 = (RuleCall)cFeaturesAssignment_4_1_1.eContents().get(0);
		private final Group cGroup_4_2 = (Group)cGroup_4.eContents().get(2);
		private final Assignment cGroupsAssignment_4_2_0 = (Assignment)cGroup_4_2.eContents().get(0);
		private final RuleCall cGroupsGroupParserRuleCall_4_2_0_0 = (RuleCall)cGroupsAssignment_4_2_0.eContents().get(0);
		private final Assignment cGroupsAssignment_4_2_1 = (Assignment)cGroup_4_2.eContents().get(1);
		private final RuleCall cGroupsGroupParserRuleCall_4_2_1_0 = (RuleCall)cGroupsAssignment_4_2_1.eContents().get(0);
		private final Group cGroup_4_3 = (Group)cGroup_4.eContents().get(3);
		private final Keyword cNumberSignKeyword_4_3_0 = (Keyword)cGroup_4_3.eContents().get(0);
		private final Assignment cConstraintsAssignment_4_3_1 = (Assignment)cGroup_4_3.eContents().get(1);
		private final RuleCall cConstraintsExpressionParserRuleCall_4_3_1_0 = (RuleCall)cConstraintsAssignment_4_3_1.eContents().get(0);
		private final Group cGroup_4_3_2 = (Group)cGroup_4_3.eContents().get(2);
		private final Keyword cNumberSignKeyword_4_3_2_0 = (Keyword)cGroup_4_3_2.eContents().get(0);
		private final Assignment cConstraintsAssignment_4_3_2_1 = (Assignment)cGroup_4_3_2.eContents().get(1);
		private final RuleCall cConstraintsExpressionParserRuleCall_4_3_2_1_0 = (RuleCall)cConstraintsAssignment_4_3_2_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4_4 = (Keyword)cGroup_4.eContents().get(4);
		
		//SolitaryFeature:
		//	"feature" required=SolitaryType? type=SimpleType? name=EString ("{" (features+=SolitaryFeature
		//	features+=SolitaryFeature*)? //groups must be declared last
		//	(groups+=Group groups+=Group*)? ("#" constraints+=Expression ("#" constraints+=Expression)*)? "}")?;
		public ParserRule getRule() { return rule; }

		//"feature" required=SolitaryType? type=SimpleType? name=EString ("{" (features+=SolitaryFeature
		//features+=SolitaryFeature*)? //groups must be declared last
		//(groups+=Group groups+=Group*)? ("#" constraints+=Expression ("#" constraints+=Expression)*)? "}")?
		public Group getGroup() { return cGroup; }

		//"feature"
		public Keyword getFeatureKeyword_0() { return cFeatureKeyword_0; }

		//required=SolitaryType?
		public Assignment getRequiredAssignment_1() { return cRequiredAssignment_1; }

		//SolitaryType
		public RuleCall getRequiredSolitaryTypeEnumRuleCall_1_0() { return cRequiredSolitaryTypeEnumRuleCall_1_0; }

		//type=SimpleType?
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//SimpleType
		public RuleCall getTypeSimpleTypeEnumRuleCall_2_0() { return cTypeSimpleTypeEnumRuleCall_2_0; }

		//name=EString
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }

		//EString
		public RuleCall getNameEStringParserRuleCall_3_0() { return cNameEStringParserRuleCall_3_0; }

		//("{" (features+=SolitaryFeature features+=SolitaryFeature*)? //groups must be declared last
		//(groups+=Group groups+=Group*)? ("#" constraints+=Expression ("#" constraints+=Expression)*)? "}")?
		public Group getGroup_4() { return cGroup_4; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4_0() { return cLeftCurlyBracketKeyword_4_0; }

		//(features+=SolitaryFeature features+=SolitaryFeature*)?
		public Group getGroup_4_1() { return cGroup_4_1; }

		//features+=SolitaryFeature
		public Assignment getFeaturesAssignment_4_1_0() { return cFeaturesAssignment_4_1_0; }

		//SolitaryFeature
		public RuleCall getFeaturesSolitaryFeatureParserRuleCall_4_1_0_0() { return cFeaturesSolitaryFeatureParserRuleCall_4_1_0_0; }

		//features+=SolitaryFeature*
		public Assignment getFeaturesAssignment_4_1_1() { return cFeaturesAssignment_4_1_1; }

		//SolitaryFeature
		public RuleCall getFeaturesSolitaryFeatureParserRuleCall_4_1_1_0() { return cFeaturesSolitaryFeatureParserRuleCall_4_1_1_0; }

		//(groups+=Group groups+=Group*)?
		public Group getGroup_4_2() { return cGroup_4_2; }

		//groups+=Group
		public Assignment getGroupsAssignment_4_2_0() { return cGroupsAssignment_4_2_0; }

		//Group
		public RuleCall getGroupsGroupParserRuleCall_4_2_0_0() { return cGroupsGroupParserRuleCall_4_2_0_0; }

		//groups+=Group*
		public Assignment getGroupsAssignment_4_2_1() { return cGroupsAssignment_4_2_1; }

		//Group
		public RuleCall getGroupsGroupParserRuleCall_4_2_1_0() { return cGroupsGroupParserRuleCall_4_2_1_0; }

		//("#" constraints+=Expression ("#" constraints+=Expression)*)?
		public Group getGroup_4_3() { return cGroup_4_3; }

		//"#"
		public Keyword getNumberSignKeyword_4_3_0() { return cNumberSignKeyword_4_3_0; }

		//constraints+=Expression
		public Assignment getConstraintsAssignment_4_3_1() { return cConstraintsAssignment_4_3_1; }

		//Expression
		public RuleCall getConstraintsExpressionParserRuleCall_4_3_1_0() { return cConstraintsExpressionParserRuleCall_4_3_1_0; }

		//("#" constraints+=Expression)*
		public Group getGroup_4_3_2() { return cGroup_4_3_2; }

		//"#"
		public Keyword getNumberSignKeyword_4_3_2_0() { return cNumberSignKeyword_4_3_2_0; }

		//constraints+=Expression
		public Assignment getConstraintsAssignment_4_3_2_1() { return cConstraintsAssignment_4_3_2_1; }

		//Expression
		public RuleCall getConstraintsExpressionParserRuleCall_4_3_2_1_0() { return cConstraintsExpressionParserRuleCall_4_3_2_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4_4() { return cRightCurlyBracketKeyword_4_4; }
	}

	public class GroupElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Group");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSelectKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInclusiveAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cInclusiveAnyKeyword_1_0 = (Keyword)cInclusiveAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cGroupedFeaturesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cGroupedFeaturesGroupedFeatureParserRuleCall_3_0 = (RuleCall)cGroupedFeaturesAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cCommaKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cGroupedFeaturesAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cGroupedFeaturesGroupedFeatureParserRuleCall_4_1_0 = (RuleCall)cGroupedFeaturesAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Group:
		//	"select" inclusive?="any"? "(" groupedFeatures+=GroupedFeature ("," groupedFeatures+=GroupedFeature)* ")";
		public ParserRule getRule() { return rule; }

		//"select" inclusive?="any"? "(" groupedFeatures+=GroupedFeature ("," groupedFeatures+=GroupedFeature)* ")"
		public Group getGroup() { return cGroup; }

		//"select"
		public Keyword getSelectKeyword_0() { return cSelectKeyword_0; }

		//inclusive?="any"?
		public Assignment getInclusiveAssignment_1() { return cInclusiveAssignment_1; }

		//"any"
		public Keyword getInclusiveAnyKeyword_1_0() { return cInclusiveAnyKeyword_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//groupedFeatures+=GroupedFeature
		public Assignment getGroupedFeaturesAssignment_3() { return cGroupedFeaturesAssignment_3; }

		//GroupedFeature
		public RuleCall getGroupedFeaturesGroupedFeatureParserRuleCall_3_0() { return cGroupedFeaturesGroupedFeatureParserRuleCall_3_0; }

		//("," groupedFeatures+=GroupedFeature)*
		public Group getGroup_4() { return cGroup_4; }

		//","
		public Keyword getCommaKeyword_4_0() { return cCommaKeyword_4_0; }

		//groupedFeatures+=GroupedFeature
		public Assignment getGroupedFeaturesAssignment_4_1() { return cGroupedFeaturesAssignment_4_1; }

		//GroupedFeature
		public RuleCall getGroupedFeaturesGroupedFeatureParserRuleCall_4_1_0() { return cGroupedFeaturesGroupedFeatureParserRuleCall_4_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class GroupedFeatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroupedFeature");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGroupedFeatureAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameEStringParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//GroupedFeature:
		//	{GroupedFeature} name=EString;
		public ParserRule getRule() { return rule; }

		//{GroupedFeature} name=EString
		public Group getGroup() { return cGroup; }

		//{GroupedFeature}
		public Action getGroupedFeatureAction_0() { return cGroupedFeatureAction_0; }

		//name=EString
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//EString
		public RuleCall getNameEStringParserRuleCall_1_0() { return cNameEStringParserRuleCall_1_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLogical2OperationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryOperationLexpAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorLogicalOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRexpAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRexpLogical2OperationParserRuleCall_1_2_0 = (RuleCall)cRexpAssignment_1_2.eContents().get(0);
		
		//Expression:
		//	Logical2Operation ({BinaryOperation.lexp=current} operator=LogicalOperator rexp=Logical2Operation)*;
		public ParserRule getRule() { return rule; }

		//Logical2Operation ({BinaryOperation.lexp=current} operator=LogicalOperator rexp=Logical2Operation)*
		public Group getGroup() { return cGroup; }

		//Logical2Operation
		public RuleCall getLogical2OperationParserRuleCall_0() { return cLogical2OperationParserRuleCall_0; }

		//({BinaryOperation.lexp=current} operator=LogicalOperator rexp=Logical2Operation)*
		public Group getGroup_1() { return cGroup_1; }

		//{BinaryOperation.lexp=current}
		public Action getBinaryOperationLexpAction_1_0() { return cBinaryOperationLexpAction_1_0; }

		//operator=LogicalOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//LogicalOperator
		public RuleCall getOperatorLogicalOperatorEnumRuleCall_1_1_0() { return cOperatorLogicalOperatorEnumRuleCall_1_1_0; }

		//rexp=Logical2Operation
		public Assignment getRexpAssignment_1_2() { return cRexpAssignment_1_2; }

		//Logical2Operation
		public RuleCall getRexpLogical2OperationParserRuleCall_1_2_0() { return cRexpLogical2OperationParserRuleCall_1_2_0; }
	}

	public class Logical2OperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Logical2Operation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBinaryOperationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryOperationLexpAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorCompareOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRexpAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRexpBinaryOperationParserRuleCall_1_2_0 = (RuleCall)cRexpAssignment_1_2.eContents().get(0);
		
		//Logical2Operation returns Expression:
		//	BinaryOperation ({BinaryOperation.lexp=current} operator=CompareOperator rexp=BinaryOperation)*;
		public ParserRule getRule() { return rule; }

		//BinaryOperation ({BinaryOperation.lexp=current} operator=CompareOperator rexp=BinaryOperation)*
		public Group getGroup() { return cGroup; }

		//BinaryOperation
		public RuleCall getBinaryOperationParserRuleCall_0() { return cBinaryOperationParserRuleCall_0; }

		//({BinaryOperation.lexp=current} operator=CompareOperator rexp=BinaryOperation)*
		public Group getGroup_1() { return cGroup_1; }

		//{BinaryOperation.lexp=current}
		public Action getBinaryOperationLexpAction_1_0() { return cBinaryOperationLexpAction_1_0; }

		//operator=CompareOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//CompareOperator
		public RuleCall getOperatorCompareOperatorEnumRuleCall_1_1_0() { return cOperatorCompareOperatorEnumRuleCall_1_1_0; }

		//rexp=BinaryOperation
		public Assignment getRexpAssignment_1_2() { return cRexpAssignment_1_2; }

		//BinaryOperation
		public RuleCall getRexpBinaryOperationParserRuleCall_1_2_0() { return cRexpBinaryOperationParserRuleCall_1_2_0; }
	}

	public class BinaryOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BinaryOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAtomicExpParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryOperationLexpAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperatorArithmicOperatorEnumRuleCall_1_1_0 = (RuleCall)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRexpAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRexpAtomicExpParserRuleCall_1_2_0 = (RuleCall)cRexpAssignment_1_2.eContents().get(0);
		
		//BinaryOperation returns Expression:
		//	AtomicExp ({BinaryOperation.lexp=current} operator=ArithmicOperator rexp=AtomicExp)*;
		public ParserRule getRule() { return rule; }

		//AtomicExp ({BinaryOperation.lexp=current} operator=ArithmicOperator rexp=AtomicExp)*
		public Group getGroup() { return cGroup; }

		//AtomicExp
		public RuleCall getAtomicExpParserRuleCall_0() { return cAtomicExpParserRuleCall_0; }

		//({BinaryOperation.lexp=current} operator=ArithmicOperator rexp=AtomicExp)*
		public Group getGroup_1() { return cGroup_1; }

		//{BinaryOperation.lexp=current}
		public Action getBinaryOperationLexpAction_1_0() { return cBinaryOperationLexpAction_1_0; }

		//operator=ArithmicOperator
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//ArithmicOperator
		public RuleCall getOperatorArithmicOperatorEnumRuleCall_1_1_0() { return cOperatorArithmicOperatorEnumRuleCall_1_1_0; }

		//rexp=AtomicExp
		public Assignment getRexpAssignment_1_2() { return cRexpAssignment_1_2; }

		//AtomicExp
		public RuleCall getRexpAtomicExpParserRuleCall_1_2_0() { return cRexpAtomicExpParserRuleCall_1_2_0; }
	}

	public class UnaryOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryOperation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperatorUnaryOperatorEnumRuleCall_0_0 = (RuleCall)cOperatorAssignment_0.eContents().get(0);
		private final Assignment cExpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpAtomicExpParserRuleCall_1_0 = (RuleCall)cExpAssignment_1.eContents().get(0);
		
		//UnaryOperation:
		//	operator=UnaryOperator exp=AtomicExp;
		public ParserRule getRule() { return rule; }

		//operator=UnaryOperator exp=AtomicExp
		public Group getGroup() { return cGroup; }

		//operator=UnaryOperator
		public Assignment getOperatorAssignment_0() { return cOperatorAssignment_0; }

		//UnaryOperator
		public RuleCall getOperatorUnaryOperatorEnumRuleCall_0_0() { return cOperatorUnaryOperatorEnumRuleCall_0_0; }

		//exp=AtomicExp
		public Assignment getExpAssignment_1() { return cExpAssignment_1; }

		//AtomicExp
		public RuleCall getExpAtomicExpParserRuleCall_1_0() { return cExpAtomicExpParserRuleCall_1_0; }
	}

	public class AtomicExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtomicExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNULLParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNumberParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIdentifierParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final RuleCall cUnaryOperationParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//AtomicExp returns Expression:
		//	NULL | Number | Identifier | "(" Expression ")" | UnaryOperation;
		public ParserRule getRule() { return rule; }

		//NULL | Number | Identifier | "(" Expression ")" | UnaryOperation
		public Alternatives getAlternatives() { return cAlternatives; }

		//NULL
		public RuleCall getNULLParserRuleCall_0() { return cNULLParserRuleCall_0; }

		//Number
		public RuleCall getNumberParserRuleCall_1() { return cNumberParserRuleCall_1; }

		//Identifier
		public RuleCall getIdentifierParserRuleCall_2() { return cIdentifierParserRuleCall_2; }

		//"(" Expression ")"
		public Group getGroup_3() { return cGroup_3; }

		//"("
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_3_1() { return cExpressionParserRuleCall_3_1; }

		//")"
		public Keyword getRightParenthesisKeyword_3_2() { return cRightParenthesisKeyword_3_2; }

		//UnaryOperation
		public RuleCall getUnaryOperationParserRuleCall_4() { return cUnaryOperationParserRuleCall_4; }
	}

	public class IdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Identifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cRefFeatureCrossReference_0_0 = (CrossReference)cRefAssignment_0.eContents().get(0);
		private final RuleCall cRefFeatureIDTerminalRuleCall_0_0_1 = (RuleCall)cRefFeatureCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cRefAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final CrossReference cRefFeatureCrossReference_1_1_0 = (CrossReference)cRefAssignment_1_1.eContents().get(0);
		private final RuleCall cRefFeatureIDTerminalRuleCall_1_1_0_1 = (RuleCall)cRefFeatureCrossReference_1_1_0.eContents().get(1);
		
		//Identifier:
		//	ref+=[Feature] ("." ref+=[Feature])*;
		public ParserRule getRule() { return rule; }

		//ref+=[Feature] ("." ref+=[Feature])*
		public Group getGroup() { return cGroup; }

		//ref+=[Feature]
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }

		//[Feature]
		public CrossReference getRefFeatureCrossReference_0_0() { return cRefFeatureCrossReference_0_0; }

		//ID
		public RuleCall getRefFeatureIDTerminalRuleCall_0_0_1() { return cRefFeatureIDTerminalRuleCall_0_0_1; }

		//("." ref+=[Feature])*
		public Group getGroup_1() { return cGroup_1; }

		//"."
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }

		//ref+=[Feature]
		public Assignment getRefAssignment_1_1() { return cRefAssignment_1_1; }

		//[Feature]
		public CrossReference getRefFeatureCrossReference_1_1_0() { return cRefFeatureCrossReference_1_1_0; }

		//ID
		public RuleCall getRefFeatureIDTerminalRuleCall_1_1_0_1() { return cRefFeatureIDTerminalRuleCall_1_1_0_1; }
	}

	public class NULLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NULL");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNULLAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNULLKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//NULL:
		//	{NULL} "NULL";
		public ParserRule getRule() { return rule; }

		//{NULL} "NULL"
		public Group getGroup() { return cGroup; }

		//{NULL}
		public Action getNULLAction_0() { return cNULLAction_0; }

		//"NULL"
		public Keyword getNULLKeyword_1() { return cNULLKeyword_1; }
	}

	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Number");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueEIntParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Number:
		//	value=EInt;
		public ParserRule getRule() { return rule; }

		//value=EInt
		public Assignment getValueAssignment() { return cValueAssignment; }

		//EInt
		public RuleCall getValueEIntParserRuleCall_0() { return cValueEIntParserRuleCall_0; }
	}

	public class EIntElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EInt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//EInt returns ecore::EInt:
		//	"-"? INT;
		public ParserRule getRule() { return rule; }

		//"-"? INT
		public Group getGroup() { return cGroup; }

		//"-"?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}

	public class EBooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EBoolean");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//EBoolean returns ecore::EBoolean:
		//	"true" | "false";
		public ParserRule getRule() { return rule; }

		//"true" | "false"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class EStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EString");
		private final RuleCall cIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//EString returns ecore::EString:
		//	ID;
		public ParserRule getRule() { return rule; }

		//ID
		public RuleCall getIDTerminalRuleCall() { return cIDTerminalRuleCall; }
	}
	
	
	public class LogicalOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "LogicalOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAndEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAndAndKeyword_0_0 = (Keyword)cAndEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOrEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cOrOrKeyword_1_0 = (Keyword)cOrEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum LogicalOperator returns BinaryOperator:
		//	And | Or;
		public EnumRule getRule() { return rule; }

		//And | Or
		public Alternatives getAlternatives() { return cAlternatives; }

		//And
		public EnumLiteralDeclaration getAndEnumLiteralDeclaration_0() { return cAndEnumLiteralDeclaration_0; }

		//"And"
		public Keyword getAndAndKeyword_0_0() { return cAndAndKeyword_0_0; }

		//Or
		public EnumLiteralDeclaration getOrEnumLiteralDeclaration_1() { return cOrEnumLiteralDeclaration_1; }

		//"Or"
		public Keyword getOrOrKeyword_1_0() { return cOrOrKeyword_1_0; }
	}

	public class CompareOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "CompareOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEqualsEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEqualsEqualsKeyword_0_0 = (Keyword)cEqualsEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cHigherEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cHigherHigherKeyword_1_0 = (Keyword)cHigherEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLowerEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLowerLowerKeyword_2_0 = (Keyword)cLowerEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum CompareOperator returns BinaryOperator:
		//	Equals | Higher | Lower;
		public EnumRule getRule() { return rule; }

		//Equals | Higher | Lower
		public Alternatives getAlternatives() { return cAlternatives; }

		//Equals
		public EnumLiteralDeclaration getEqualsEnumLiteralDeclaration_0() { return cEqualsEnumLiteralDeclaration_0; }

		//"Equals"
		public Keyword getEqualsEqualsKeyword_0_0() { return cEqualsEqualsKeyword_0_0; }

		//Higher
		public EnumLiteralDeclaration getHigherEnumLiteralDeclaration_1() { return cHigherEnumLiteralDeclaration_1; }

		//"Higher"
		public Keyword getHigherHigherKeyword_1_0() { return cHigherHigherKeyword_1_0; }

		//Lower
		public EnumLiteralDeclaration getLowerEnumLiteralDeclaration_2() { return cLowerEnumLiteralDeclaration_2; }

		//"Lower"
		public Keyword getLowerLowerKeyword_2_0() { return cLowerLowerKeyword_2_0; }
	}

	public class ArithmicOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmicOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAddEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAddAddKeyword_0_0 = (Keyword)cAddEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSubtractEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSubtractSubtractKeyword_1_0 = (Keyword)cSubtractEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDivideEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDivideDivideKeyword_2_0 = (Keyword)cDivideEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cMultiplyEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cMultiplyMultiplyKeyword_3_0 = (Keyword)cMultiplyEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum ArithmicOperator returns BinaryOperator:
		//	Add | Subtract | Divide | Multiply;
		public EnumRule getRule() { return rule; }

		//Add | Subtract | Divide | Multiply
		public Alternatives getAlternatives() { return cAlternatives; }

		//Add
		public EnumLiteralDeclaration getAddEnumLiteralDeclaration_0() { return cAddEnumLiteralDeclaration_0; }

		//"Add"
		public Keyword getAddAddKeyword_0_0() { return cAddAddKeyword_0_0; }

		//Subtract
		public EnumLiteralDeclaration getSubtractEnumLiteralDeclaration_1() { return cSubtractEnumLiteralDeclaration_1; }

		//"Subtract"
		public Keyword getSubtractSubtractKeyword_1_0() { return cSubtractSubtractKeyword_1_0; }

		//Divide
		public EnumLiteralDeclaration getDivideEnumLiteralDeclaration_2() { return cDivideEnumLiteralDeclaration_2; }

		//"Divide"
		public Keyword getDivideDivideKeyword_2_0() { return cDivideDivideKeyword_2_0; }

		//Multiply
		public EnumLiteralDeclaration getMultiplyEnumLiteralDeclaration_3() { return cMultiplyEnumLiteralDeclaration_3; }

		//"Multiply"
		public Keyword getMultiplyMultiplyKeyword_3_0() { return cMultiplyMultiplyKeyword_3_0; }
	}

	public class UnaryOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNotEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNotNotKeyword_0_0 = (Keyword)cNotEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMinusEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMinusMinusKeyword_1_0 = (Keyword)cMinusEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum UnaryOperator:
		//	Not | Minus;
		public EnumRule getRule() { return rule; }

		//Not | Minus
		public Alternatives getAlternatives() { return cAlternatives; }

		//Not
		public EnumLiteralDeclaration getNotEnumLiteralDeclaration_0() { return cNotEnumLiteralDeclaration_0; }

		//"Not"
		public Keyword getNotNotKeyword_0_0() { return cNotNotKeyword_0_0; }

		//Minus
		public EnumLiteralDeclaration getMinusEnumLiteralDeclaration_1() { return cMinusEnumLiteralDeclaration_1; }

		//"Minus"
		public Keyword getMinusMinusKeyword_1_0() { return cMinusMinusKeyword_1_0; }
	}

	public class SimpleTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "SimpleType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBooleanEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBooleanBooleanKeyword_0_0 = (Keyword)cBooleanEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cIntEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cIntIntKeyword_1_0 = (Keyword)cIntEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDoubleEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDoubleDoubleKeyword_2_0 = (Keyword)cDoubleEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cStringEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cStringStringKeyword_3_0 = (Keyword)cStringEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum SimpleType:
		//	boolean | int | double | String;
		public EnumRule getRule() { return rule; }

		//boolean | int | double | String
		public Alternatives getAlternatives() { return cAlternatives; }

		//boolean
		public EnumLiteralDeclaration getBooleanEnumLiteralDeclaration_0() { return cBooleanEnumLiteralDeclaration_0; }

		//"boolean"
		public Keyword getBooleanBooleanKeyword_0_0() { return cBooleanBooleanKeyword_0_0; }

		//int
		public EnumLiteralDeclaration getIntEnumLiteralDeclaration_1() { return cIntEnumLiteralDeclaration_1; }

		//"int"
		public Keyword getIntIntKeyword_1_0() { return cIntIntKeyword_1_0; }

		//double
		public EnumLiteralDeclaration getDoubleEnumLiteralDeclaration_2() { return cDoubleEnumLiteralDeclaration_2; }

		//"double"
		public Keyword getDoubleDoubleKeyword_2_0() { return cDoubleDoubleKeyword_2_0; }

		//String
		public EnumLiteralDeclaration getStringEnumLiteralDeclaration_3() { return cStringEnumLiteralDeclaration_3; }

		//"String"
		public Keyword getStringStringKeyword_3_0() { return cStringStringKeyword_3_0; }
	}

	public class SolitaryTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "SolitaryType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cOptionalEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cOptionalOptionalKeyword_0_0 = (Keyword)cOptionalEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMandatoryEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMandatoryMandatoryKeyword_1_0 = (Keyword)cMandatoryEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum SolitaryType:
		//	Optional | Mandatory;
		public EnumRule getRule() { return rule; }

		//Optional | Mandatory
		public Alternatives getAlternatives() { return cAlternatives; }

		//Optional
		public EnumLiteralDeclaration getOptionalEnumLiteralDeclaration_0() { return cOptionalEnumLiteralDeclaration_0; }

		//"Optional"
		public Keyword getOptionalOptionalKeyword_0_0() { return cOptionalOptionalKeyword_0_0; }

		//Mandatory
		public EnumLiteralDeclaration getMandatoryEnumLiteralDeclaration_1() { return cMandatoryEnumLiteralDeclaration_1; }

		//"Mandatory"
		public Keyword getMandatoryMandatoryKeyword_1_0() { return cMandatoryMandatoryKeyword_1_0; }
	}
	
	private ModelElements pModel;
	private FeatureElements pFeature;
	private SolitaryFeatureElements pSolitaryFeature;
	private GroupElements pGroup;
	private GroupedFeatureElements pGroupedFeature;
	private ExpressionElements pExpression;
	private Logical2OperationElements pLogical2Operation;
	private BinaryOperationElements pBinaryOperation;
	private UnaryOperationElements pUnaryOperation;
	private AtomicExpElements pAtomicExp;
	private IdentifierElements pIdentifier;
	private LogicalOperatorElements unknownRuleLogicalOperator;
	private CompareOperatorElements unknownRuleCompareOperator;
	private ArithmicOperatorElements unknownRuleArithmicOperator;
	private UnaryOperatorElements unknownRuleUnaryOperator;
	private NULLElements pNULL;
	private NumberElements pNumber;
	private EIntElements pEInt;
	private EBooleanElements pEBoolean;
	private SimpleTypeElements unknownRuleSimpleType;
	private SolitaryTypeElements unknownRuleSolitaryType;
	private EStringElements pEString;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public MyDslGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.mydsl1.MyDsl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	{Model} "Model" "{" ("Root" RootFeature+=Feature ("Root" RootFeature+=Feature)*)? "}";
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//Feature:
	//	SolitaryFeature | GroupedFeature;
	public FeatureElements getFeatureAccess() {
		return (pFeature != null) ? pFeature : (pFeature = new FeatureElements());
	}
	
	public ParserRule getFeatureRule() {
		return getFeatureAccess().getRule();
	}

	//SolitaryFeature:
	//	"feature" required=SolitaryType? type=SimpleType? name=EString ("{" (features+=SolitaryFeature
	//	features+=SolitaryFeature*)? //groups must be declared last
	//	(groups+=Group groups+=Group*)? ("#" constraints+=Expression ("#" constraints+=Expression)*)? "}")?;
	public SolitaryFeatureElements getSolitaryFeatureAccess() {
		return (pSolitaryFeature != null) ? pSolitaryFeature : (pSolitaryFeature = new SolitaryFeatureElements());
	}
	
	public ParserRule getSolitaryFeatureRule() {
		return getSolitaryFeatureAccess().getRule();
	}

	//Group:
	//	"select" inclusive?="any"? "(" groupedFeatures+=GroupedFeature ("," groupedFeatures+=GroupedFeature)* ")";
	public GroupElements getGroupAccess() {
		return (pGroup != null) ? pGroup : (pGroup = new GroupElements());
	}
	
	public ParserRule getGroupRule() {
		return getGroupAccess().getRule();
	}

	//GroupedFeature:
	//	{GroupedFeature} name=EString;
	public GroupedFeatureElements getGroupedFeatureAccess() {
		return (pGroupedFeature != null) ? pGroupedFeature : (pGroupedFeature = new GroupedFeatureElements());
	}
	
	public ParserRule getGroupedFeatureRule() {
		return getGroupedFeatureAccess().getRule();
	}

	//Expression:
	//	Logical2Operation ({BinaryOperation.lexp=current} operator=LogicalOperator rexp=Logical2Operation)*;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//Logical2Operation returns Expression:
	//	BinaryOperation ({BinaryOperation.lexp=current} operator=CompareOperator rexp=BinaryOperation)*;
	public Logical2OperationElements getLogical2OperationAccess() {
		return (pLogical2Operation != null) ? pLogical2Operation : (pLogical2Operation = new Logical2OperationElements());
	}
	
	public ParserRule getLogical2OperationRule() {
		return getLogical2OperationAccess().getRule();
	}

	//BinaryOperation returns Expression:
	//	AtomicExp ({BinaryOperation.lexp=current} operator=ArithmicOperator rexp=AtomicExp)*;
	public BinaryOperationElements getBinaryOperationAccess() {
		return (pBinaryOperation != null) ? pBinaryOperation : (pBinaryOperation = new BinaryOperationElements());
	}
	
	public ParserRule getBinaryOperationRule() {
		return getBinaryOperationAccess().getRule();
	}

	//UnaryOperation:
	//	operator=UnaryOperator exp=AtomicExp;
	public UnaryOperationElements getUnaryOperationAccess() {
		return (pUnaryOperation != null) ? pUnaryOperation : (pUnaryOperation = new UnaryOperationElements());
	}
	
	public ParserRule getUnaryOperationRule() {
		return getUnaryOperationAccess().getRule();
	}

	//AtomicExp returns Expression:
	//	NULL | Number | Identifier | "(" Expression ")" | UnaryOperation;
	public AtomicExpElements getAtomicExpAccess() {
		return (pAtomicExp != null) ? pAtomicExp : (pAtomicExp = new AtomicExpElements());
	}
	
	public ParserRule getAtomicExpRule() {
		return getAtomicExpAccess().getRule();
	}

	//Identifier:
	//	ref+=[Feature] ("." ref+=[Feature])*;
	public IdentifierElements getIdentifierAccess() {
		return (pIdentifier != null) ? pIdentifier : (pIdentifier = new IdentifierElements());
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}

	//enum LogicalOperator returns BinaryOperator:
	//	And | Or;
	public LogicalOperatorElements getLogicalOperatorAccess() {
		return (unknownRuleLogicalOperator != null) ? unknownRuleLogicalOperator : (unknownRuleLogicalOperator = new LogicalOperatorElements());
	}
	
	public EnumRule getLogicalOperatorRule() {
		return getLogicalOperatorAccess().getRule();
	}

	//enum CompareOperator returns BinaryOperator:
	//	Equals | Higher | Lower;
	public CompareOperatorElements getCompareOperatorAccess() {
		return (unknownRuleCompareOperator != null) ? unknownRuleCompareOperator : (unknownRuleCompareOperator = new CompareOperatorElements());
	}
	
	public EnumRule getCompareOperatorRule() {
		return getCompareOperatorAccess().getRule();
	}

	//enum ArithmicOperator returns BinaryOperator:
	//	Add | Subtract | Divide | Multiply;
	public ArithmicOperatorElements getArithmicOperatorAccess() {
		return (unknownRuleArithmicOperator != null) ? unknownRuleArithmicOperator : (unknownRuleArithmicOperator = new ArithmicOperatorElements());
	}
	
	public EnumRule getArithmicOperatorRule() {
		return getArithmicOperatorAccess().getRule();
	}

	//enum UnaryOperator:
	//	Not | Minus;
	public UnaryOperatorElements getUnaryOperatorAccess() {
		return (unknownRuleUnaryOperator != null) ? unknownRuleUnaryOperator : (unknownRuleUnaryOperator = new UnaryOperatorElements());
	}
	
	public EnumRule getUnaryOperatorRule() {
		return getUnaryOperatorAccess().getRule();
	}

	//NULL:
	//	{NULL} "NULL";
	public NULLElements getNULLAccess() {
		return (pNULL != null) ? pNULL : (pNULL = new NULLElements());
	}
	
	public ParserRule getNULLRule() {
		return getNULLAccess().getRule();
	}

	//Number:
	//	value=EInt;
	public NumberElements getNumberAccess() {
		return (pNumber != null) ? pNumber : (pNumber = new NumberElements());
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}

	//EInt returns ecore::EInt:
	//	"-"? INT;
	public EIntElements getEIntAccess() {
		return (pEInt != null) ? pEInt : (pEInt = new EIntElements());
	}
	
	public ParserRule getEIntRule() {
		return getEIntAccess().getRule();
	}

	//EBoolean returns ecore::EBoolean:
	//	"true" | "false";
	public EBooleanElements getEBooleanAccess() {
		return (pEBoolean != null) ? pEBoolean : (pEBoolean = new EBooleanElements());
	}
	
	public ParserRule getEBooleanRule() {
		return getEBooleanAccess().getRule();
	}

	//enum SimpleType:
	//	boolean | int | double | String;
	public SimpleTypeElements getSimpleTypeAccess() {
		return (unknownRuleSimpleType != null) ? unknownRuleSimpleType : (unknownRuleSimpleType = new SimpleTypeElements());
	}
	
	public EnumRule getSimpleTypeRule() {
		return getSimpleTypeAccess().getRule();
	}

	//enum SolitaryType:
	//	Optional | Mandatory;
	public SolitaryTypeElements getSolitaryTypeAccess() {
		return (unknownRuleSolitaryType != null) ? unknownRuleSolitaryType : (unknownRuleSolitaryType = new SolitaryTypeElements());
	}
	
	public EnumRule getSolitaryTypeRule() {
		return getSolitaryTypeAccess().getRule();
	}

	//EString returns ecore::EString:
	//	ID;
	public EStringElements getEStringAccess() {
		return (pEString != null) ? pEString : (pEString = new EStringElements());
	}
	
	public ParserRule getEStringRule() {
		return getEStringAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
